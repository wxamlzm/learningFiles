<!--
 * @Author: zd
 * @Date: 2023-12-05 11:19:51
 * @LastEditors: zd
 * @LastEditTime: 2024-01-18 16:44:28
 * @Description:
-->

## javascript

- `Number.prototype.toFixed()` MDN 上的翻译是错的，toFixed 不是绝对意义上的四舍五入，也不是银行计数，追溯见 js 标准

- 防抖函数，且第一次运行

```
  debounce (func, delay) {
    let timer = null // 定时器并利用闭包保存
    let count = 0
    return function () {
      const context = this // 记录 this 值,防止在回调函数中丢失
      const args = arguments // 函数参数
      // 首次立刻执行
      if (count === 0) {
        count++
        func.apply(context, args)
        timer = setTimeout(() => {
          // 防止 this 值变为 window
          func.apply(context, args)
        }, delay)
      } else {
        count++
        // 如果定时器存在，则清除定时器(如果没有,也没必要进行处理)
        if (timer) {
          clearTimeout(timer)
          timer = null
        }

        timer = setTimeout(() => {
          // 防止 this 值变为 window
          func.apply(context, args)
        }, delay)
      }
    }
  }
```

- IOS 移动端页面有自带的拉扯 DOM 效果，中文社区称为橡皮筋效应，暂时没有好的解决办法

- 附加- scroll 是可以进行自定义样式设置的，但这个伪类样式是非标准功能

- 接上，为了处理滚轴监听时的橡皮筋效果，做了滚轴 scrollTop 的数值控制，逻辑就是 scrollTop 和外层 DOM 高度的和是不会高于内层 DOM 高度；

- 碰到了 touchmove 和 touchstart 的应用出问题的情况，具体来讲 touchstart 在屏幕滚动过程中无法触发

- `transition: all 0.3s;` 可以作为基础的过度样式的代码，但前提是更新前后的样式里都必须有对应的的值

- 一个关于柯里化的例子

```
function getAddress(province){
 return function (city) {
   return function (area) {
     return province + city + area;
   }
 }
}

getAddress('浙江省')('杭州市')('西湖区');    //浙江省杭州市西湖区
```

- 偏函数就是函数作为变量？

- 社区里有人提到了前端的`polyfill`和兼容性有关，可以了解一下

- 二级表单可能会有跨表单校验的需求，比如外层日期读取到内层后要求在两者之间，内层设置好后，出来再次改了外层,这种需要解决方案

- 闭包：在一个作用域中可以访问另一个函数内部的局部变量的函数（函数可以通过作用域链相互关联起来，函数提内部的变量都可以保存在函数作用域内，这种特性称为闭包)

- 防抖

```
// 防抖
export const debounce = (fn, delay) => {
  let timer = null
  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
    }, delay)
  }
}
```

- 防抖注意问题，低级问题，防抖的核心是闭包的应用，需要在作用域外能有一个调用；简单的说重复调用 debounceFn=debounce(fn,delay) 还是会产生不同的地址吧

- 自定义

```
       password: [
         { required: true, message: "请输入密码", trigger: "blur" },
         { min: 6, max: 20, message: "长度在 6 到 20 个字符", trigger: "blur" },
         {
           validator: (rule, value, callback) => {
             if (value === "123456") {
               callback(new Error("密码不能为 '123456'"));
             } else {
               callback();
             }
           },
           trigger: "blur",
         },
       ]
```

- el-ui 的 form 中的表单校验，可以通过`rules`属性中的对应 props 的`validate`属性进行自定义校验

- el-form 的 rules 的表单的动态添加规则的时候需要用到解构，可以衍生到所有新增双向绑定么

- vue.config.js 中的`publicPath` 属性，可以用于为添加基础路由

- `String.split()` 可以放正则

- https://v1.test-utils.vuejs.org/zh/ vue 自带的单元测试介绍地址

- 前端 vue2 的 jest 测试中，会碰到 jest 不支持 webpack 的 node 代码的情况，比如下列代码

```
   5 | Vue.use(Vuex)
       6 | // https://webpack.js.org/guides/dependency-management/#requirecontext
    >  7 | const modulesFiles = require.context('./modules', true, /\.js$/)
```

单就这个问题而已，可以安装`babel-plugin-transform-require-context`后在`babel`的配置文件中配置下列配置文件来解决

```
  env: {
    test: {
      plugins: ['transform-require-context']
    }
  }
```

- const charArray = [...('' + num)]; // ["1", "2", "3", "4", "5"]

- `in` `prop in object`
- 改 main 需要重新启动啊，傻逼

- 算法，从顶向下（Top-Down）是一种解决问题的方法论，通常“顶”是指整体

- ` client: { overlay: false },`
